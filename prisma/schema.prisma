generator nextAdmin {
    provider              = "next-admin-generator-prisma"
  }
generator client {
  provider   = "prisma-client"
  output     = "./generated"
  engineType = "client"
}

datasource db {
  provider = "postgresql"
}

enum ComponentCategory {
  gpu
  cpu
  monitor
}

enum DeviceCategory {
  keyboard
  mouse
  headset
}

enum MatchStatus {
  SCHEDULED
  LIVE
  COMPLETED
}

model Zone {
  id          Int   @id @default(autoincrement())
  slug        String   @unique
  name        String
  description String
  image       String
  price       String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @default(now())

  // Relations
  components ZoneComponent[]
  devices    ZoneDevice[]
  photos     ZonePhoto[]
}

model ZoneComponent {
  id       Int            @id @default(autoincrement())
  category ComponentCategory // "gpu", "cpu", "monitor"
  order    Int               @default(0)
  model    String
  specs    String
  zoneId   Int
  zone     Zone              @relation(fields: [zoneId], references: [id], onDelete: Cascade)
}

model ZoneDevice {
  id       Int         @id @default(autoincrement())
  category DeviceCategory // "keyboard", "mouse", "headset"
  order    Int            @default(0)
  model    String
  specs    String
  zoneId   Int
  zone     Zone           @relation(fields: [zoneId], references: [id], onDelete: Cascade)
}

model ZonePhoto {
  id     Int @id @default(autoincrement())
  url    String
  alt    String
  order  Int    @default(0)
  zoneId Int
  zone   Zone   @relation(fields: [zoneId], references: [id], onDelete: Cascade)
}

model Tournament {
  id                  String           @id @default(uuid(4))
  slug                String           @unique
  name                String
  description         String?
  date                DateTime
  time                String
  status              TournamentStatus @default(REGISTRATION)
  prize               String
  maxParticipants     Int
  image               String?
  rules               String?
  streamUrl           String?
  createdAt           DateTime         @default(now())
  updatedAt           DateTime         @updatedAt

  gameId              Int
  game                Game @relation(fields: [gameId], references: [id])

  matches             Match[]
  teams               TournamentTeam[]
}

model TournamentTeam {
  id           String   @id @default(uuid())
  placement    Int?
  tournamentId String
  teamId       String
  registeredAt DateTime @default(now())

  tournament   Tournament @relation(fields: [tournamentId], references: [id])
  team         Team       @relation(fields: [teamId], references: [id])

  @@unique([tournamentId, teamId])
}

model Team {
  id        String   @id @default(uuid())
  name      String
  tag       String   @unique
  logo      String?
  createdAt DateTime @default(now())

  players   TeamPlayer[]

  matchesAsA Match[] @relation("TeamA")
  matchesAsB Match[] @relation("TeamB")
  wins       Match[] @relation("Winner")

  tournaments TournamentTeam[]
}


model TeamPlayer {
  id        String   @id @default(uuid())
  teamId    String
  userId    String

  team      Team @relation(fields: [teamId], references: [id])
  user      Player @relation(fields: [userId], references: [id])

  @@unique([teamId, userId])
}

model Match {
  id            String   @id @default(uuid())
  tournamentId  String
  map           String?
  duration      Int?
  round         Int
  bestOf        Int
  status        MatchStatus @default(SCHEDULED)
  startTime     DateTime?

  teamAId       String
  teamBId       String
  winnerId      String?

  scoreA        Int?
  scoreB        Int?

  tournament    Tournament @relation(fields: [tournamentId], references: [id])

  teamA         Team @relation("TeamA", fields: [teamAId], references: [id])
  teamB         Team @relation("TeamB", fields: [teamBId], references: [id])
  winner        Team? @relation("Winner", fields: [winnerId], references: [id])

  @@index([tournamentId])
}


model Game {
  id          Int       @id @default(autoincrement())
  name        String
  tournaments Tournament[]
}

enum TournamentStatus {
  REGISTRATION
  ONGOING
  COMPLETED
  CANCELLED
}

model Player {
  id        String   @id @default(uuid(4))
  nickname  String   @unique
  avatar    String?
  rating    Int      @default(1000)
  rank      Int?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  achievements     PlayerAchievement[]
  socialLinks      PlayerSocialLink[]

  teamPlayers TeamPlayer[]
}

model PlayerAchievement {
  id          String            @id @default(uuid(4))
  name        String
  description String
  icon        String?
  rarity      AchievementRarity @default(COMMON)
  earnedAt    DateTime          @default(now())
  playerId    String
  player      Player            @relation(fields: [playerId], references: [id], onDelete: Cascade)
}

enum AchievementRarity {
  COMMON
  RARE
  EPIC
  LEGENDARY
}

model PlayerSocialLink {
  id       String @id @default(cuid())
  platform String // steam, discord, twitch, youtube
  url      String
  playerId String
  player   Player @relation(fields: [playerId], references: [id], onDelete: Cascade)
}

model News {
  id           String    @id @default(uuid(4))
  slug         String    @unique
  title        String
  excerpt      String
  content      String
  image        String?
  category     String
  published    Boolean   @default(false)
  featured     Boolean   @default(false)
  authorName   String?
  authorAvatar String?
  publishedAt  DateTime?
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt

  // Relations
  tags NewsTag[]
}

model NewsTag {
  id     Int @id @default(autoincrement())
  name   String
  newsId String
  news   News   @relation(fields: [newsId], references: [id], onDelete: Cascade)
}

model Admins {
  id        String   @id @default(uuid())
  username  String   @unique
  password  String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}
